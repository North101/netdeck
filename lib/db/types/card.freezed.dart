// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'card.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

CardData _$CardDataFromJson(Map<String, dynamic> json) {
  return _CardData.fromJson(json);
}

/// @nodoc
mixin _$CardData {
  String get code => throw _privateConstructorUsedError;
  String get packCode => throw _privateConstructorUsedError;
  String get factionCode => throw _privateConstructorUsedError;
  String get typeCode => throw _privateConstructorUsedError;
  int get position => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String? get body => throw _privateConstructorUsedError;
  String? get keywords => throw _privateConstructorUsedError;
  int get quantity => throw _privateConstructorUsedError;
  int? get cost => throw _privateConstructorUsedError;
  int get deckLimit => throw _privateConstructorUsedError;
  int get factionCost => throw _privateConstructorUsedError;
  bool get uniqueness => throw _privateConstructorUsedError;
  int? get strength => throw _privateConstructorUsedError;
  int? get agendaPoints => throw _privateConstructorUsedError;
  int? get memoryCost => throw _privateConstructorUsedError;
  int? get advancementCost => throw _privateConstructorUsedError;
  int? get trashCost => throw _privateConstructorUsedError;
  int? get baseLink => throw _privateConstructorUsedError;
  int? get influenceLimit => throw _privateConstructorUsedError;
  int? get minimumDeckSize => throw _privateConstructorUsedError;
  String? get flavor => throw _privateConstructorUsedError;
  String? get illustrator => throw _privateConstructorUsedError;
  String get imageUrl => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CardDataCopyWith<CardData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CardDataCopyWith<$Res> {
  factory $CardDataCopyWith(CardData value, $Res Function(CardData) then) =
      _$CardDataCopyWithImpl<$Res, CardData>;
  @useResult
  $Res call(
      {String code,
      String packCode,
      String factionCode,
      String typeCode,
      int position,
      String title,
      String? body,
      String? keywords,
      int quantity,
      int? cost,
      int deckLimit,
      int factionCost,
      bool uniqueness,
      int? strength,
      int? agendaPoints,
      int? memoryCost,
      int? advancementCost,
      int? trashCost,
      int? baseLink,
      int? influenceLimit,
      int? minimumDeckSize,
      String? flavor,
      String? illustrator,
      String imageUrl});
}

/// @nodoc
class _$CardDataCopyWithImpl<$Res, $Val extends CardData>
    implements $CardDataCopyWith<$Res> {
  _$CardDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? packCode = null,
    Object? factionCode = null,
    Object? typeCode = null,
    Object? position = null,
    Object? title = null,
    Object? body = freezed,
    Object? keywords = freezed,
    Object? quantity = null,
    Object? cost = freezed,
    Object? deckLimit = null,
    Object? factionCost = null,
    Object? uniqueness = null,
    Object? strength = freezed,
    Object? agendaPoints = freezed,
    Object? memoryCost = freezed,
    Object? advancementCost = freezed,
    Object? trashCost = freezed,
    Object? baseLink = freezed,
    Object? influenceLimit = freezed,
    Object? minimumDeckSize = freezed,
    Object? flavor = freezed,
    Object? illustrator = freezed,
    Object? imageUrl = null,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      packCode: null == packCode
          ? _value.packCode
          : packCode // ignore: cast_nullable_to_non_nullable
              as String,
      factionCode: null == factionCode
          ? _value.factionCode
          : factionCode // ignore: cast_nullable_to_non_nullable
              as String,
      typeCode: null == typeCode
          ? _value.typeCode
          : typeCode // ignore: cast_nullable_to_non_nullable
              as String,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as int,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      body: freezed == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      keywords: freezed == keywords
          ? _value.keywords
          : keywords // ignore: cast_nullable_to_non_nullable
              as String?,
      quantity: null == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as int,
      cost: freezed == cost
          ? _value.cost
          : cost // ignore: cast_nullable_to_non_nullable
              as int?,
      deckLimit: null == deckLimit
          ? _value.deckLimit
          : deckLimit // ignore: cast_nullable_to_non_nullable
              as int,
      factionCost: null == factionCost
          ? _value.factionCost
          : factionCost // ignore: cast_nullable_to_non_nullable
              as int,
      uniqueness: null == uniqueness
          ? _value.uniqueness
          : uniqueness // ignore: cast_nullable_to_non_nullable
              as bool,
      strength: freezed == strength
          ? _value.strength
          : strength // ignore: cast_nullable_to_non_nullable
              as int?,
      agendaPoints: freezed == agendaPoints
          ? _value.agendaPoints
          : agendaPoints // ignore: cast_nullable_to_non_nullable
              as int?,
      memoryCost: freezed == memoryCost
          ? _value.memoryCost
          : memoryCost // ignore: cast_nullable_to_non_nullable
              as int?,
      advancementCost: freezed == advancementCost
          ? _value.advancementCost
          : advancementCost // ignore: cast_nullable_to_non_nullable
              as int?,
      trashCost: freezed == trashCost
          ? _value.trashCost
          : trashCost // ignore: cast_nullable_to_non_nullable
              as int?,
      baseLink: freezed == baseLink
          ? _value.baseLink
          : baseLink // ignore: cast_nullable_to_non_nullable
              as int?,
      influenceLimit: freezed == influenceLimit
          ? _value.influenceLimit
          : influenceLimit // ignore: cast_nullable_to_non_nullable
              as int?,
      minimumDeckSize: freezed == minimumDeckSize
          ? _value.minimumDeckSize
          : minimumDeckSize // ignore: cast_nullable_to_non_nullable
              as int?,
      flavor: freezed == flavor
          ? _value.flavor
          : flavor // ignore: cast_nullable_to_non_nullable
              as String?,
      illustrator: freezed == illustrator
          ? _value.illustrator
          : illustrator // ignore: cast_nullable_to_non_nullable
              as String?,
      imageUrl: null == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CardDataCopyWith<$Res> implements $CardDataCopyWith<$Res> {
  factory _$$_CardDataCopyWith(
          _$_CardData value, $Res Function(_$_CardData) then) =
      __$$_CardDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String code,
      String packCode,
      String factionCode,
      String typeCode,
      int position,
      String title,
      String? body,
      String? keywords,
      int quantity,
      int? cost,
      int deckLimit,
      int factionCost,
      bool uniqueness,
      int? strength,
      int? agendaPoints,
      int? memoryCost,
      int? advancementCost,
      int? trashCost,
      int? baseLink,
      int? influenceLimit,
      int? minimumDeckSize,
      String? flavor,
      String? illustrator,
      String imageUrl});
}

/// @nodoc
class __$$_CardDataCopyWithImpl<$Res>
    extends _$CardDataCopyWithImpl<$Res, _$_CardData>
    implements _$$_CardDataCopyWith<$Res> {
  __$$_CardDataCopyWithImpl(
      _$_CardData _value, $Res Function(_$_CardData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? packCode = null,
    Object? factionCode = null,
    Object? typeCode = null,
    Object? position = null,
    Object? title = null,
    Object? body = freezed,
    Object? keywords = freezed,
    Object? quantity = null,
    Object? cost = freezed,
    Object? deckLimit = null,
    Object? factionCost = null,
    Object? uniqueness = null,
    Object? strength = freezed,
    Object? agendaPoints = freezed,
    Object? memoryCost = freezed,
    Object? advancementCost = freezed,
    Object? trashCost = freezed,
    Object? baseLink = freezed,
    Object? influenceLimit = freezed,
    Object? minimumDeckSize = freezed,
    Object? flavor = freezed,
    Object? illustrator = freezed,
    Object? imageUrl = null,
  }) {
    return _then(_$_CardData(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      packCode: null == packCode
          ? _value.packCode
          : packCode // ignore: cast_nullable_to_non_nullable
              as String,
      factionCode: null == factionCode
          ? _value.factionCode
          : factionCode // ignore: cast_nullable_to_non_nullable
              as String,
      typeCode: null == typeCode
          ? _value.typeCode
          : typeCode // ignore: cast_nullable_to_non_nullable
              as String,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as int,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      body: freezed == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as String?,
      keywords: freezed == keywords
          ? _value.keywords
          : keywords // ignore: cast_nullable_to_non_nullable
              as String?,
      quantity: null == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as int,
      cost: freezed == cost
          ? _value.cost
          : cost // ignore: cast_nullable_to_non_nullable
              as int?,
      deckLimit: null == deckLimit
          ? _value.deckLimit
          : deckLimit // ignore: cast_nullable_to_non_nullable
              as int,
      factionCost: null == factionCost
          ? _value.factionCost
          : factionCost // ignore: cast_nullable_to_non_nullable
              as int,
      uniqueness: null == uniqueness
          ? _value.uniqueness
          : uniqueness // ignore: cast_nullable_to_non_nullable
              as bool,
      strength: freezed == strength
          ? _value.strength
          : strength // ignore: cast_nullable_to_non_nullable
              as int?,
      agendaPoints: freezed == agendaPoints
          ? _value.agendaPoints
          : agendaPoints // ignore: cast_nullable_to_non_nullable
              as int?,
      memoryCost: freezed == memoryCost
          ? _value.memoryCost
          : memoryCost // ignore: cast_nullable_to_non_nullable
              as int?,
      advancementCost: freezed == advancementCost
          ? _value.advancementCost
          : advancementCost // ignore: cast_nullable_to_non_nullable
              as int?,
      trashCost: freezed == trashCost
          ? _value.trashCost
          : trashCost // ignore: cast_nullable_to_non_nullable
              as int?,
      baseLink: freezed == baseLink
          ? _value.baseLink
          : baseLink // ignore: cast_nullable_to_non_nullable
              as int?,
      influenceLimit: freezed == influenceLimit
          ? _value.influenceLimit
          : influenceLimit // ignore: cast_nullable_to_non_nullable
              as int?,
      minimumDeckSize: freezed == minimumDeckSize
          ? _value.minimumDeckSize
          : minimumDeckSize // ignore: cast_nullable_to_non_nullable
              as int?,
      flavor: freezed == flavor
          ? _value.flavor
          : flavor // ignore: cast_nullable_to_non_nullable
              as String?,
      illustrator: freezed == illustrator
          ? _value.illustrator
          : illustrator // ignore: cast_nullable_to_non_nullable
              as String?,
      imageUrl: null == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CardData extends _CardData {
  const _$_CardData(
      {required this.code,
      required this.packCode,
      required this.factionCode,
      required this.typeCode,
      required this.position,
      required this.title,
      required this.body,
      required this.keywords,
      required this.quantity,
      required this.cost,
      required this.deckLimit,
      required this.factionCost,
      required this.uniqueness,
      required this.strength,
      required this.agendaPoints,
      required this.memoryCost,
      required this.advancementCost,
      required this.trashCost,
      required this.baseLink,
      required this.influenceLimit,
      required this.minimumDeckSize,
      required this.flavor,
      required this.illustrator,
      required this.imageUrl})
      : super._();

  factory _$_CardData.fromJson(Map<String, dynamic> json) =>
      _$$_CardDataFromJson(json);

  @override
  final String code;
  @override
  final String packCode;
  @override
  final String factionCode;
  @override
  final String typeCode;
  @override
  final int position;
  @override
  final String title;
  @override
  final String? body;
  @override
  final String? keywords;
  @override
  final int quantity;
  @override
  final int? cost;
  @override
  final int deckLimit;
  @override
  final int factionCost;
  @override
  final bool uniqueness;
  @override
  final int? strength;
  @override
  final int? agendaPoints;
  @override
  final int? memoryCost;
  @override
  final int? advancementCost;
  @override
  final int? trashCost;
  @override
  final int? baseLink;
  @override
  final int? influenceLimit;
  @override
  final int? minimumDeckSize;
  @override
  final String? flavor;
  @override
  final String? illustrator;
  @override
  final String imageUrl;

  @override
  String toString() {
    return 'CardData(code: $code, packCode: $packCode, factionCode: $factionCode, typeCode: $typeCode, position: $position, title: $title, body: $body, keywords: $keywords, quantity: $quantity, cost: $cost, deckLimit: $deckLimit, factionCost: $factionCost, uniqueness: $uniqueness, strength: $strength, agendaPoints: $agendaPoints, memoryCost: $memoryCost, advancementCost: $advancementCost, trashCost: $trashCost, baseLink: $baseLink, influenceLimit: $influenceLimit, minimumDeckSize: $minimumDeckSize, flavor: $flavor, illustrator: $illustrator, imageUrl: $imageUrl)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CardData &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.packCode, packCode) ||
                other.packCode == packCode) &&
            (identical(other.factionCode, factionCode) ||
                other.factionCode == factionCode) &&
            (identical(other.typeCode, typeCode) ||
                other.typeCode == typeCode) &&
            (identical(other.position, position) ||
                other.position == position) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.keywords, keywords) ||
                other.keywords == keywords) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.cost, cost) || other.cost == cost) &&
            (identical(other.deckLimit, deckLimit) ||
                other.deckLimit == deckLimit) &&
            (identical(other.factionCost, factionCost) ||
                other.factionCost == factionCost) &&
            (identical(other.uniqueness, uniqueness) ||
                other.uniqueness == uniqueness) &&
            (identical(other.strength, strength) ||
                other.strength == strength) &&
            (identical(other.agendaPoints, agendaPoints) ||
                other.agendaPoints == agendaPoints) &&
            (identical(other.memoryCost, memoryCost) ||
                other.memoryCost == memoryCost) &&
            (identical(other.advancementCost, advancementCost) ||
                other.advancementCost == advancementCost) &&
            (identical(other.trashCost, trashCost) ||
                other.trashCost == trashCost) &&
            (identical(other.baseLink, baseLink) ||
                other.baseLink == baseLink) &&
            (identical(other.influenceLimit, influenceLimit) ||
                other.influenceLimit == influenceLimit) &&
            (identical(other.minimumDeckSize, minimumDeckSize) ||
                other.minimumDeckSize == minimumDeckSize) &&
            (identical(other.flavor, flavor) || other.flavor == flavor) &&
            (identical(other.illustrator, illustrator) ||
                other.illustrator == illustrator) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        code,
        packCode,
        factionCode,
        typeCode,
        position,
        title,
        body,
        keywords,
        quantity,
        cost,
        deckLimit,
        factionCost,
        uniqueness,
        strength,
        agendaPoints,
        memoryCost,
        advancementCost,
        trashCost,
        baseLink,
        influenceLimit,
        minimumDeckSize,
        flavor,
        illustrator,
        imageUrl
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CardDataCopyWith<_$_CardData> get copyWith =>
      __$$_CardDataCopyWithImpl<_$_CardData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CardDataToJson(
      this,
    );
  }
}

abstract class _CardData extends CardData {
  const factory _CardData(
      {required final String code,
      required final String packCode,
      required final String factionCode,
      required final String typeCode,
      required final int position,
      required final String title,
      required final String? body,
      required final String? keywords,
      required final int quantity,
      required final int? cost,
      required final int deckLimit,
      required final int factionCost,
      required final bool uniqueness,
      required final int? strength,
      required final int? agendaPoints,
      required final int? memoryCost,
      required final int? advancementCost,
      required final int? trashCost,
      required final int? baseLink,
      required final int? influenceLimit,
      required final int? minimumDeckSize,
      required final String? flavor,
      required final String? illustrator,
      required final String imageUrl}) = _$_CardData;
  const _CardData._() : super._();

  factory _CardData.fromJson(Map<String, dynamic> json) = _$_CardData.fromJson;

  @override
  String get code;
  @override
  String get packCode;
  @override
  String get factionCode;
  @override
  String get typeCode;
  @override
  int get position;
  @override
  String get title;
  @override
  String? get body;
  @override
  String? get keywords;
  @override
  int get quantity;
  @override
  int? get cost;
  @override
  int get deckLimit;
  @override
  int get factionCost;
  @override
  bool get uniqueness;
  @override
  int? get strength;
  @override
  int? get agendaPoints;
  @override
  int? get memoryCost;
  @override
  int? get advancementCost;
  @override
  int? get trashCost;
  @override
  int? get baseLink;
  @override
  int? get influenceLimit;
  @override
  int? get minimumDeckSize;
  @override
  String? get flavor;
  @override
  String? get illustrator;
  @override
  String get imageUrl;
  @override
  @JsonKey(ignore: true)
  _$$_CardDataCopyWith<_$_CardData> get copyWith =>
      throw _privateConstructorUsedError;
}

CardResult _$CardResultFromJson(Map<String, dynamic> json) {
  return _CardResult.fromJson(json);
}

/// @nodoc
mixin _$CardResult {
  CardData get card => throw _privateConstructorUsedError;
  PackData get pack => throw _privateConstructorUsedError;
  CycleData get cycle => throw _privateConstructorUsedError;
  FactionData get faction => throw _privateConstructorUsedError;
  SideData get side => throw _privateConstructorUsedError;
  TypeData get type => throw _privateConstructorUsedError;
  TypeData? get subtype => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CardResultCopyWith<CardResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CardResultCopyWith<$Res> {
  factory $CardResultCopyWith(
          CardResult value, $Res Function(CardResult) then) =
      _$CardResultCopyWithImpl<$Res, CardResult>;
  @useResult
  $Res call(
      {CardData card,
      PackData pack,
      CycleData cycle,
      FactionData faction,
      SideData side,
      TypeData type,
      TypeData? subtype});

  $CardDataCopyWith<$Res> get card;
  $PackDataCopyWith<$Res> get pack;
  $CycleDataCopyWith<$Res> get cycle;
  $FactionDataCopyWith<$Res> get faction;
  $SideDataCopyWith<$Res> get side;
  $TypeDataCopyWith<$Res> get type;
  $TypeDataCopyWith<$Res>? get subtype;
}

/// @nodoc
class _$CardResultCopyWithImpl<$Res, $Val extends CardResult>
    implements $CardResultCopyWith<$Res> {
  _$CardResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? card = null,
    Object? pack = null,
    Object? cycle = null,
    Object? faction = null,
    Object? side = null,
    Object? type = null,
    Object? subtype = freezed,
  }) {
    return _then(_value.copyWith(
      card: null == card
          ? _value.card
          : card // ignore: cast_nullable_to_non_nullable
              as CardData,
      pack: null == pack
          ? _value.pack
          : pack // ignore: cast_nullable_to_non_nullable
              as PackData,
      cycle: null == cycle
          ? _value.cycle
          : cycle // ignore: cast_nullable_to_non_nullable
              as CycleData,
      faction: null == faction
          ? _value.faction
          : faction // ignore: cast_nullable_to_non_nullable
              as FactionData,
      side: null == side
          ? _value.side
          : side // ignore: cast_nullable_to_non_nullable
              as SideData,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as TypeData,
      subtype: freezed == subtype
          ? _value.subtype
          : subtype // ignore: cast_nullable_to_non_nullable
              as TypeData?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CardDataCopyWith<$Res> get card {
    return $CardDataCopyWith<$Res>(_value.card, (value) {
      return _then(_value.copyWith(card: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PackDataCopyWith<$Res> get pack {
    return $PackDataCopyWith<$Res>(_value.pack, (value) {
      return _then(_value.copyWith(pack: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CycleDataCopyWith<$Res> get cycle {
    return $CycleDataCopyWith<$Res>(_value.cycle, (value) {
      return _then(_value.copyWith(cycle: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FactionDataCopyWith<$Res> get faction {
    return $FactionDataCopyWith<$Res>(_value.faction, (value) {
      return _then(_value.copyWith(faction: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SideDataCopyWith<$Res> get side {
    return $SideDataCopyWith<$Res>(_value.side, (value) {
      return _then(_value.copyWith(side: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TypeDataCopyWith<$Res> get type {
    return $TypeDataCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TypeDataCopyWith<$Res>? get subtype {
    if (_value.subtype == null) {
      return null;
    }

    return $TypeDataCopyWith<$Res>(_value.subtype!, (value) {
      return _then(_value.copyWith(subtype: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_CardResultCopyWith<$Res>
    implements $CardResultCopyWith<$Res> {
  factory _$$_CardResultCopyWith(
          _$_CardResult value, $Res Function(_$_CardResult) then) =
      __$$_CardResultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {CardData card,
      PackData pack,
      CycleData cycle,
      FactionData faction,
      SideData side,
      TypeData type,
      TypeData? subtype});

  @override
  $CardDataCopyWith<$Res> get card;
  @override
  $PackDataCopyWith<$Res> get pack;
  @override
  $CycleDataCopyWith<$Res> get cycle;
  @override
  $FactionDataCopyWith<$Res> get faction;
  @override
  $SideDataCopyWith<$Res> get side;
  @override
  $TypeDataCopyWith<$Res> get type;
  @override
  $TypeDataCopyWith<$Res>? get subtype;
}

/// @nodoc
class __$$_CardResultCopyWithImpl<$Res>
    extends _$CardResultCopyWithImpl<$Res, _$_CardResult>
    implements _$$_CardResultCopyWith<$Res> {
  __$$_CardResultCopyWithImpl(
      _$_CardResult _value, $Res Function(_$_CardResult) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? card = null,
    Object? pack = null,
    Object? cycle = null,
    Object? faction = null,
    Object? side = null,
    Object? type = null,
    Object? subtype = freezed,
  }) {
    return _then(_$_CardResult(
      card: null == card
          ? _value.card
          : card // ignore: cast_nullable_to_non_nullable
              as CardData,
      pack: null == pack
          ? _value.pack
          : pack // ignore: cast_nullable_to_non_nullable
              as PackData,
      cycle: null == cycle
          ? _value.cycle
          : cycle // ignore: cast_nullable_to_non_nullable
              as CycleData,
      faction: null == faction
          ? _value.faction
          : faction // ignore: cast_nullable_to_non_nullable
              as FactionData,
      side: null == side
          ? _value.side
          : side // ignore: cast_nullable_to_non_nullable
              as SideData,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as TypeData,
      subtype: freezed == subtype
          ? _value.subtype
          : subtype // ignore: cast_nullable_to_non_nullable
              as TypeData?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CardResult extends _CardResult {
  const _$_CardResult(
      {required this.card,
      required this.pack,
      required this.cycle,
      required this.faction,
      required this.side,
      required this.type,
      required this.subtype})
      : super._();

  factory _$_CardResult.fromJson(Map<String, dynamic> json) =>
      _$$_CardResultFromJson(json);

  @override
  final CardData card;
  @override
  final PackData pack;
  @override
  final CycleData cycle;
  @override
  final FactionData faction;
  @override
  final SideData side;
  @override
  final TypeData type;
  @override
  final TypeData? subtype;

  @override
  String toString() {
    return 'CardResult(card: $card, pack: $pack, cycle: $cycle, faction: $faction, side: $side, type: $type, subtype: $subtype)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CardResult &&
            (identical(other.card, card) || other.card == card) &&
            (identical(other.pack, pack) || other.pack == pack) &&
            (identical(other.cycle, cycle) || other.cycle == cycle) &&
            (identical(other.faction, faction) || other.faction == faction) &&
            (identical(other.side, side) || other.side == side) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.subtype, subtype) || other.subtype == subtype));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, card, pack, cycle, faction, side, type, subtype);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CardResultCopyWith<_$_CardResult> get copyWith =>
      __$$_CardResultCopyWithImpl<_$_CardResult>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CardResultToJson(
      this,
    );
  }
}

abstract class _CardResult extends CardResult {
  const factory _CardResult(
      {required final CardData card,
      required final PackData pack,
      required final CycleData cycle,
      required final FactionData faction,
      required final SideData side,
      required final TypeData type,
      required final TypeData? subtype}) = _$_CardResult;
  const _CardResult._() : super._();

  factory _CardResult.fromJson(Map<String, dynamic> json) =
      _$_CardResult.fromJson;

  @override
  CardData get card;
  @override
  PackData get pack;
  @override
  CycleData get cycle;
  @override
  FactionData get faction;
  @override
  SideData get side;
  @override
  TypeData get type;
  @override
  TypeData? get subtype;
  @override
  @JsonKey(ignore: true)
  _$$_CardResultCopyWith<_$_CardResult> get copyWith =>
      throw _privateConstructorUsedError;
}
